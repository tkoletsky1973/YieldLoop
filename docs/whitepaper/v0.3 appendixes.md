## Appendix A — System State Machine

This appendix defines the **complete state machine** for YieldLoop vaults and execution.
It exists to eliminate undefined behavior, prevent state ambiguity, and support deterministic implementation and audit.

All vaults—user and system-owned—must conform to this state model.

Recovery State cannot produce a worse outcome than a standard zero-result cycle and exists solely to preserve user control and accounting integrity.

---

### A.1 State Overview

Each vault exists in **exactly one state** at any given time.

Valid states are:

1. **Idle**
2. **Configured**
3. **Authorized**
4. **Active Execution**
5. **Halted Execution**
6. **Settlement**
7. **Recovery State**
8. **Closed**

No other states are permitted.

---

### A.2 State Definitions

#### A.2.1 Idle

**Description:**  
The default state of a vault.

**Characteristics:**
- No active cycle
- Funds are idle
- Withdrawals enabled
- Configuration allowed
- No execution permitted

**Allowed Transitions:**
- Idle → Configured

**Prohibited Actions:**
- Execution
- Settlement
- LOOP minting
- Fee assessment

---

#### A.2.2 Configured

**Description:**  
The vault has execution parameters defined but is not yet committed.

**Characteristics:**
- Strategy modules selected
- Parameters defined
- Funds still withdrawable
- No execution occurring

**Allowed Transitions:**
- Configured → Authorized
- Configured → Idle

**Prohibited Actions:**
- Execution
- Parameter mutation after authorization
- Settlement

---

#### A.2.3 Authorized

**Description:**  
The user has explicitly authorized a cycle.

**Characteristics:**
- Parameters locked
- Withdrawals disabled
- Cycle clock initialized
- Execution not yet started

**Allowed Transitions:**
- Authorized → Active Execution
- Authorized → Settlement (edge case: zero-length or aborted start)

**Prohibited Actions:**
- Parameter changes
- Withdrawals
- Strategy modification

---

#### A.2.4 Active Execution

**Description:**  
Strategy modules are actively operating within the vault.

**Characteristics:**
- Execution permitted only via authorized strategies
- No user or admin intervention
- No withdrawals
- No configuration changes

**Allowed Transitions:**
- Active Execution → Settlement (normal completion)
- Active Execution → Halted Execution (failure or halt condition)
- Active Execution → Settlement (time expiry)

**Prohibited Actions:**
- Parameter changes
- Execution substitution
- Manual overrides
- LOOP minting
- Fee settlement

---

#### A.2.5 Halted Execution

**Description:**  
Execution has stopped early due to failure or emergency halt.

**Characteristics:**
- No further execution permitted
- Vault remains locked
- No retries or substitutions
- Accounting not yet finalized

**Allowed Transitions:**
- Halted Execution → Settlement

**Prohibited Actions:**
- Resuming execution
- Changing parameters
- Withdrawing funds

---

#### A.2.6 Settlement

**Description:**  
Final accounting and outcome determination.

**Characteristics:**
- Execution permanently stopped
- Balances snapshotted
- Costs deducted
- Profit evaluated
- Fees applied if eligible
- LOOP minting evaluated

**Allowed Transitions:**
- Settlement → Closed
- Settlement → Recovery State (only if settlement cannot complete)

**Prohibited Actions:**
- Execution
- Parameter changes
- Withdrawals
- Re-entry into execution states

---

#### A.2.7 Recovery State

**Description:**  
Fallback state when settlement cannot complete deterministically.

**Characteristics:**
- Execution permanently halted
- No LOOP minting
- No fees charged
- Withdrawals re-enabled
- Accounting finalized using last verifiable state

**Allowed Transitions:**
- Recovery State → Closed

**Prohibited Actions:**
- Execution
- Re-settlement
- Manual outcome adjustment

---

#### A.2.8 Closed

**Description:**  
Terminal state for a completed cycle.

**Characteristics:**
- Results finalized
- Vault unlocked
- Withdrawals enabled
- Historical data immutable

**Allowed Transitions:**
- Closed → Idle (new cycle may begin)

**Prohibited Actions:**
- Modifying past outcomes
- Reopening the cycle

---

### A.3 State Transition Table

| From State         | To State            | Trigger                                   |
|-------------------|---------------------|-------------------------------------------|
| Idle              | Configured          | User defines parameters                   |
| Configured        | Authorized          | User authorizes cycle                     |
| Configured        | Idle                | User cancels configuration                |
| Authorized        | Active Execution    | Execution begins                           |
| Authorized        | Settlement          | Execution aborted before start            |
| Active Execution  | Settlement          | Normal completion or time expiry           |
| Active Execution  | Halted Execution    | Failure or emergency halt                 |
| Halted Execution  | Settlement          | Automatic transition                      |
| Settlement        | Closed              | Settlement completes successfully         |
| Settlement        | Recovery State      | Settlement cannot complete deterministically |
| Recovery State    | Closed              | Recovery finalization                     |
| Closed            | Idle                | New cycle initiation                      |

---

### A.4 Invariant Enforcement

The following invariants apply across all states:

- Execution may occur **only** in Active Execution
- Settlement may occur **only once per cycle**
- Withdrawals are enabled **only** in Idle and Closed
- Parameters are mutable **only** in Configured
- LOOP minting is evaluated **only** during Settlement
- Fees apply **only** if profit is verified at Settlement

Any state violation must cause an immediate revert.

---

### A.5 Why the State Machine Matters

This state machine exists to:

- Prevent partial execution ambiguity
- Eliminate mid-cycle discretion
- Guarantee finality
- Enable deterministic audits
- Make failure survivable

If an action cannot be mapped to a valid state transition, it is invalid by definition.

There are no implicit states.
There are no shortcuts.

---

### A.6 State Flow (Simplified) 

Idle
 │
 │ configure
 ▼
Configured
 │
 │ authorize
 ▼
Authorized
 │
 │ begin execution
 ▼
Active Execution
 │
 ├── failure / emergency halt ──▶ Halted Execution
 │                                │
 │                                ▼
 │                           Settlement
 │
 └── normal completion ─────────▶ Settlement
                                    │
                                    ├── success ──▶ Closed
                                    │
                                    └── cannot finalize ──▶ Recovery State ──▶ Closed
                                                           
Closed
 │
 │ new cycle
 ▼
Idle


---

### A.7 Mermaid Diagram

stateDiagram-v2
    [*] --> Idle

    Idle --> Configured : configure
    Configured --> Authorized : authorize
    Configured --> Idle : cancel

    Authorized --> ActiveExecution : begin execution
    Authorized --> Settlement : abort before start

    ActiveExecution --> Settlement : normal completion
    ActiveExecution --> HaltedExecution : failure / emergency halt

    HaltedExecution --> Settlement

    Settlement --> Closed : settlement complete
    Settlement --> RecoveryState : cannot finalize

    RecoveryState --> Closed

    Closed --> Idle : new cycle

    ---

    ## Appendix B — Settlement Math & Valuation Rules

This appendix defines **exact settlement math** and **deterministic valuation rules**.

Settlement is the only moment where YieldLoop recognizes cycle-level profit.
If settlement cannot be computed deterministically, the cycle resolves to **Recovery State** and **no fees / no LOOP** are permitted.

---

### B.1 Settlement Inputs (Authoritative Data)

Settlement relies only on on-chain verifiable inputs:

- `t0`: cycle start timestamp (authorization time)
- `t1`: cycle end timestamp (scheduled end or halt time)
- `S`: starting vault balances snapshot at `t0`
- `E`: ending vault balances snapshot at `t1`
- `C_gas`: total gas costs paid by the vault during the cycle
- `C_exec`: total execution costs (bot/operator/service fees if applicable and on-chain verifiable)
- `C_proto`: protocol-level fees or costs incurred by the vault (DEX fees, pool fees, claim fees)
- `V( )`: valuation function (deterministic, defined below)

No off-chain estimates are permitted.

---

### B.2 Asset Balance Snapshot Rules

#### B.2.1 Snapshot Timing
- Starting snapshot `S` is captured immediately upon cycle authorization (or first execution event, if defined).
- Ending snapshot `E` is captured immediately when execution has fully stopped and settlement begins.

#### B.2.2 Included Balances
A snapshot must include:
- All ERC-20 token balances held by the vault
- Native token balance (if applicable)
- Any strategy-specific wrapped equivalents explicitly declared in strategy specs

Excluded by default unless explicitly supported:
- Unclaimed rewards
- Pending LP fees not yet claimable to the vault
- External positions that cannot be reduced to deterministic balances at settlement time

Rule:
> If it is not an actual balance in the vault at settlement time, it does not exist for settlement.

---

### B.3 Valuation Function `V( )`

Settlement requires a deterministic conversion of multi-asset holdings into a single **Base Asset** (e.g., USDC or equivalent).

#### B.3.1 Base Asset
- Each vault has a declared base asset for settlement (e.g., USDC).
- All values are computed in base-asset terms.

#### B.3.2 Deterministic Pricing
Valuation must use one of the following deterministic sources (implementation-defined, but fixed and auditable):

1. **On-chain oracle price** at a defined block (preferred)
2. **DEX TWAP** over a fixed window ending at `t1`
3. **DEX spot price** at a defined block (allowed only if oracle/TWAP unavailable)

A single settlement must use **one pricing source per asset**.
Mixing sources for the same asset within a settlement is prohibited.

#### B.3.3 Price Ambiguity Rule (Hard)
If price cannot be resolved deterministically (oracle stale, TWAP unavailable, pool illiquid, etc.):

- Settlement must **exclude** that asset from valuation **or**
- Trigger Recovery State (implementation choice, but must be consistent and documented)

Default rule recommended:
> If any required asset valuation is ambiguous, settlement fails and enters Recovery State.

---

### B.4 Net Result Calculation (Canonical)

Let:
- `V(S)` = value of starting snapshot in base asset
- `V(E)` = value of ending snapshot in base asset

Costs are represented in base asset terms:

- `C_total = C_gas + C_exec + C_proto`

Then:

gross_change = V(E) - V(S)
net_result   = gross_change - C_total

Profit condition:

- If `net_result > 0` → Verified profit exists
- If `net_result ≤ 0` → Outcome is non-positive and treated as zero

There is no partial credit.

---

### B.5 Profit Recognition Rules

#### B.5.1 Execution-Level Profit vs Cycle-Level Surplus
- Execution-level realized proceeds may occur during the cycle.
- Cycle-level profit exists only at settlement.

Settlement ignores “feelings” of profit during execution.
Only `net_result` matters.

#### B.5.2 Unrealized Value Exclusion
Unrealized changes in external position value are excluded unless they are reduced to vault balances at settlement.

Rule:
> If you can’t snapshot it as a vault balance, it’s not in the math.

---

### B.6 Fee Calculation Rules (Settlement)

Fees apply **only** if `net_result > 0`.

Let:
- `f` = platform fee rate (prospective and cycle-locked)
- `P = net_result`

Then:

fee_amount = f * P
user_profit_after_fee = P - fee_amount

Fee constraints:
- Fees cannot exceed profit
- Fees cannot be taken from principal
- No profit → `fee_amount = 0`

---

### B.7 LOOP Eligibility Input (Retained Surplus)

Only the platform-retained portion that is designated for LOOP eligibility is considered for minting.

Let:
- `R` = portion of `fee_amount` (or other retained surplus defined by protocol) eligible for LOOP conversion
- `m` = Dynamic Mint Ratio (DMR), bounded, prospective, cycle-locked

Then:

LOOP_minted = m * R
unminted_retained_surplus = (1 - m) * R


Rules:
- LOOP minting is evaluated only in settlement
- No settlement → no LOOP
- Recovery State → no LOOP

---

### B.8 Rounding, Precision, and Dust

All settlement math must specify:
- Fixed decimal precision for base asset computations (e.g., 1e6 or 1e18 units)
- Rounding direction (recommended: round **down** to avoid over-crediting)
- Dust threshold rules (minimum values treated as zero)

Recommended rounding principle:
> Rounding must never create profit that did not exist.

---

### B.9 Settlement Determinism and Finality

Settlement must be:
- Deterministic (same inputs → same outputs)
- Atomic (single finalization point)
- Idempotent (cannot apply twice)

Once settlement completes:
- Results are immutable
- Accounting entries are permanent
- No retroactive adjustment is permitted

---

### B.10 Recovery State Trigger Conditions

Settlement transitions to Recovery State if any of the following occurs:

- Required valuation source is unavailable or ambiguous
- Critical settlement call repeatedly reverts beyond defined retry limits
- Required balances cannot be snapshotted deterministically
- Any invariants required for settlement correctness cannot be proven

Recovery rules (hard):
- Execution is permanently halted
- No fees may be collected
- No LOOP may be minted
- Withdrawals are re-enabled
- Accounting finalizes using last verifiable state

---

### B.11 Worked Example (Simple)

Assume base asset is USDC.

- `V(S) = 1,000.00`
- `V(E) = 1,060.00`
- `C_total = 20.00`

gross_change = 1,060.00 - 1,000.00 = 60.00
net_result   = 60.00 - 20.00       = 40.00  (profit exists)

If platform fee is `f = 0.20`:

fee_amount = 0.20 * 40.00 = 8.00
user_profit_after_fee = 40.00 - 8.00 = 32.00

If LOOP-eligible retained surplus is `R = 8.00` and `m = 0.50`:

LOOP_minted = 0.50 * 8.00 = 4.00
unminted_retained_surplus = 4.00

If instead `V(E)=1,010.00`:

gross_change = 10.00
net_result   = 10.00 - 20.00 = -10.00  (non-positive)
Outcome: zero, no fees, no LOOP

---

## Appendix C — Zero-Result and Dormancy Scenarios

This appendix enumerates scenarios where a cycle correctly resolves to **zero** and where the system may remain **dormant** for extended periods.

Zero is not a failure state.
Dormancy is not a malfunction.
Both are expected and correct outcomes under YieldLoop’s rules.

---

### C.1 Definition of a Zero-Result Cycle

A cycle resolves to a zero result when **net_result ≤ 0** at settlement, after all costs.

A zero result means:
- No platform fees are charged
- No LOOP is minted
- No incentives trigger
- The cycle closes normally

Zero is final and requires no explanation.

---

### C.2 Common Zero-Result Scenarios

The following scenarios **must** resolve to zero if they produce no verified surplus:

1. **Flat Price Movement**
   - Asset prices remain unchanged
   - Costs (gas, fees) consume any small gains

2. **Partial Profit Consumed by Costs**
   - Execution generates gross gains
   - Net gains are eliminated by costs

3. **Early Execution Halt**
   - Strategy halts due to constraints or failure
   - Remaining balances do not exceed starting value

4. **Liquidity Slippage**
   - Trades execute with higher-than-expected slippage
   - Gross gains fail to survive settlement math

5. **Unclaimed Rewards**
   - Rewards accrue but are not claimable at settlement
   - Unclaimed value is excluded by rule

6. **Valuation Ambiguity (Resolved Conservatively)**
   - An asset valuation is resolved at zero per policy
   - Net result becomes non-positive

In all cases, zero is the correct and final outcome.

---

### C.3 Zero Does Not Imply Loss of Principal

A zero-result cycle does **not** necessarily mean the user lost funds.

It means:
- The cycle produced no verified surplus after costs

Users may:
- Retain principal
- Withdraw immediately after settlement
- Re-authorize a new cycle or remain idle

Zero is informational, not punitive.

---

### C.4 Dormancy Scenarios

Dormancy occurs when the system intentionally does little or nothing.

Common dormancy conditions include:
- Unfavorable market conditions
- Low liquidity
- Elevated gas costs
- Strategy constraints preventing safe execution
- Governance-paused strategy availability

During dormancy:
- Cycles may be rare or absent
- LOOP supply may not grow
- System-owned capital may remain idle

This is expected behavior.

---

### C.5 Extended Dormancy Is Safe

The system is designed to remain safe during extended dormancy:

- No emissions occur
- No fees are extracted
- No user funds are placed at risk
- No accounting drift occurs

Dormancy does not degrade system integrity.

---

### C.6 Dormancy vs Failure

Dormancy must not be confused with failure.

Failure implies:
- Broken invariants
- Inability to settle
- Loss of funds due to system error

Dormancy implies:
- Conscious non-action
- Risk avoidance
- Honest acknowledgment of conditions

YieldLoop prefers dormancy over forced activity.

---

### C.7 Why Zero and Dormancy Matter

Most systems try to avoid zero outcomes because they appear unproductive.

YieldLoop embraces them because they are truthful.

Zero-result cycles and dormant periods:
- Prevent silent loss
- Expose real conditions
- Preserve capital
- Maintain trust

They are not edge cases.
They are core behaviors.

---

## Appendix D — LOOP Definitions & Edge Cases

This appendix provides **precise definitions**, boundary conditions, and edge-case handling for LOOP.
Its purpose is to eliminate ambiguity about what LOOP represents and what it cannot represent.

Nothing in this appendix expands LOOP’s role beyond what is defined in the core document.

---

### D.1 Canonical Definition of LOOP

LOOP is an internal accounting token that represents a proportional record of **verified, retained surplus** that already exists.

Formally:

> LOOP may be minted only as a consequence of finalized surplus that has survived execution, settlement, and all costs.

LOOP is evidence of past success, not a claim on future performance.

---

### D.2 LOOP Supply Invariants

The following invariants apply at all times:

- LOOP supply starts at zero
- LOOP supply may increase only during settlement
- LOOP supply may never exceed retained surplus (in base-asset terms)
- LOOP supply may stagnate indefinitely
- LOOP supply growth is independent of TVL, deposits, or user count

Any mechanism that violates these invariants is invalid by definition.

---

### D.3 Minting Edge Cases

#### D.3.1 Partial Retention
If only a portion of verified surplus is designated as LOOP-eligible:

- Only that portion may be considered for minting
- Non-eligible retained surplus remains unminted
- Unminted surplus still strengthens the accounting floor

#### D.3.2 Dynamic Mint Ratio at Zero
If the Dynamic Mint Ratio (DMR) is set to zero:

- No LOOP is minted
- All retained surplus remains unminted
- LOOP supply remains unchanged
- The accounting floor may still strengthen

This is a valid configuration.

---

### D.4 Supply Stagnation

LOOP supply may remain unchanged for extended periods due to:

- Zero-result cycles
- Dormancy
- DMR throttling
- Insufficient retained surplus

Supply stagnation is not an error condition.

---

### D.5 Accounting Floor Edge Cases

#### D.5.1 Undefined Floor (Zero Supply)
When LOOP supply is zero:

- The accounting floor is undefined
- No floor value is displayed
- No implied valuation exists

This state persists until the first successful mint.

#### D.5.2 Floor Increase Without Minting
The accounting floor may increase even if no LOOP is minted, if:

- Retained surplus grows
- LOOP supply remains constant

This behavior is mechanical and expected.

---

### D.6 Redemption Eligibility Edge Cases

Redemption is subject to system conditions and availability of retained surplus.

#### D.6.1 Insufficient Liquidity
If retained surplus is illiquid or unavailable:

- Redemption may be paused
- Requests may be queued
- Partial fulfillment may occur

This does not invalidate LOOP.

#### D.6.2 System-Wide Pause
If execution is globally paused:

- Redemption behavior is governed by defined fallback rules
- No new LOOP may be minted
- Existing LOOP remains valid

---

### D.7 LOOP and User Behavior

Holding LOOP:
- Does not affect execution
- Does not grant preferential treatment
- Does not reduce fees
- Does not influence strategy behavior

Using LOOP:
- Does not imply endorsement
- Does not guarantee value
- Does not obligate the system beyond available surplus

---

### D.8 Misinterpretations Explicitly Rejected

The following interpretations are invalid:

- LOOP represents future yield
- LOOP represents a promise of redemption at a fixed price
- LOOP price is guaranteed to rise
- LOOP protects against loss
- LOOP substitutes for accounting truth

Any messaging implying these interpretations is incorrect.

---

### D.9 Why These Definitions Matter

Most token failures occur at the edges, not the center.

By defining LOOP strictly and conservatively:
- Expectations remain bounded
- Accounting remains honest
- Survivability increases

LOOP exists to record reality—not to improve it.

---

## Appendix E — Time, Cycles, and Cutoffs

This appendix defines all time-related rules governing execution, settlement, and state transitions.
Its purpose is to eliminate ambiguity around timing, ordering, and expiration.

Time in YieldLoop is not continuous—it is segmented, bounded, and enforced.

---

### E.1 Time Authority

All time-based decisions use **on-chain block data** as the authoritative source.

- Block timestamps are used for cycle boundaries
- Block numbers may be used as secondary references where appropriate
- Off-chain clocks are never authoritative

If block time is ambiguous, conservative resolution applies.

---

### E.2 Cycle Duration

Each cycle has a defined duration set at authorization.

Rules:
- Duration is immutable once authorized
- Duration applies uniformly across strategies in the cycle
- Duration may not be extended mid-cycle
- Duration may not be shortened except via failure or halt

Cycles end when:
- The duration elapses, or
- Execution halts early due to failure or emergency halt

---

### E.3 Authorization Cutoffs

Authorization establishes the start of a cycle.

Rules:
- Authorization time is captured atomically
- No execution may occur before authorization
- Authorization cannot be replayed or duplicated
- Multiple authorizations require separate cycles

If authorization fails, the cycle does not exist.

---

### E.4 Execution Timing

Execution timing follows strict ordering:

1. Authorization completes
2. Cycle enters Authorized state
3. Execution begins
4. Execution ends
5. Settlement begins

Execution may:
- Occur immediately after authorization
- Be delayed by system scheduling
- Halt early if conditions fail

Execution may not:
- Start before authorization
- Resume after halting
- Extend beyond cycle end

---

### E.5 Settlement Timing

Settlement timing is strictly enforced.

Rules:
- Settlement begins only after execution has fully stopped
- Settlement is evaluated once per cycle
- Settlement may be retried if transient failures occur
- Settlement must complete before withdrawals are re-enabled

No execution may occur during settlement.

---

### E.6 Retry Windows

Retry behavior applies only to settlement, not execution.

Rules:
- Any caller may attempt settlement
- Retries are allowed only for deterministic failures (e.g., temporary revert)
- Retry attempts are bounded by a protocol-defined limit
- Exceeding retry limits triggers Recovery State

Retries do not modify inputs.

---

### E.7 Recovery Timeouts

If settlement cannot complete within a defined window:

- The vault enters Recovery State
- Execution is permanently halted
- LOOP minting is disabled
- Fees are disabled
- Withdrawals are re-enabled
- Accounting finalizes using last verifiable state

Recovery State is terminal for the cycle.

---

### E.8 Cutoff Enforcement

Cutoffs are enforced to prevent ambiguity:

- No late execution
- No late settlement
- No delayed accounting
- No retroactive changes

If a cutoff is missed, conservative resolution applies.

---

### E.9 Clock Drift and Chain Instability

In the event of:
- Block timestamp drift
- Chain congestion
- Temporary chain halts

The system resolves conservatively:
- Preferring earlier cutoffs
- Avoiding execution resumption
- Preserving settlement integrity

Time ambiguity never justifies optimistic accounting.

---

### E.10 Why Time Discipline Matters

Most systems blur time to hide failure.

YieldLoop enforces time to expose it.

By bounding execution and settlement in time:
- Results become auditable
- States remain deterministic
- Finality is guaranteed

Time is not a suggestion.

It is a constraint.

---

## Appendix F — Strategy Engine Specifications

This appendix defines the **formal requirements** for strategy modules in YieldLoop.
Its purpose is to ensure that all strategies are safe, auditable, bounded, and non-deceptive.

No strategy may be deployed unless it satisfies every requirement in this appendix.

---

### F.1 Strategy Role and Scope

A strategy module is a **constrained execution component**.

It:
- Executes predefined actions
- Operates only within an authorized vault
- Runs only during Active Execution
- Produces no claims, projections, or guarantees

A strategy may **fail**, **halt**, or **produce zero** without violating protocol rules.

---

### F.2 Required Strategy Interface

Every strategy must implement the following interface (conceptual):

initialize(parameters)
execute()
halt()
finalize()

Definitions:
- `initialize`: validates parameters and prepares execution
- `execute`: performs authorized actions
- `halt`: immediately stops execution
- `finalize`: performs cleanup prior to settlement

No other callable functions may affect vault balances.

---

### F.3 Determinism Requirement

Strategies must be deterministic.

Given identical:
- Inputs
- Parameters
- On-chain state

The strategy must behave identically.

Prohibited behaviors:
- Randomness
- Adaptive learning
- External off-chain signals
- Human-in-the-loop decisions
- Dynamic parameter mutation

If determinism cannot be guaranteed, the strategy is invalid.

---

### F.4 Parameter Constraints

All strategy parameters must:
- Be explicitly declared
- Have defined bounds
- Be validated at initialization
- Be immutable once authorized

Examples:
- Max trade size
- Slippage tolerance
- Asset allowlists
- Execution frequency
- Exposure limits

Parameters may not be inferred or modified mid-cycle.

---

### F.5 Capital Access Rules

Strategies may access **only** the capital explicitly allocated to them.

Rules:
- No cross-strategy borrowing
- No capital reallocation mid-cycle
- No vault-wide discretionary access
- No access to system-owned funds unless explicitly authorized

Capital isolation is mandatory.

---

### F.6 Prohibited Strategy Behaviors

Strategies must not:

- Use leverage
- Borrow or lend assets
- Enter derivatives or margin positions
- Rehypothecate assets
- Perform flash loans
- Short assets
- Chain strategies together implicitly
- Depend on continuous liquidity
- Mask losses via token rewards

If a strategy requires these behaviors, it is out of scope.

---

### F.7 External Protocol Interaction

Strategies may interact with external protocols only if:

- The interaction is explicitly defined
- All calls are bounded and auditable
- Failure modes are documented
- Reverts halt execution immediately

Retries are prohibited unless explicitly authorized and bounded.

---

### F.8 Halt Conditions

A strategy must halt immediately if:

- Slippage exceeds bounds
- Liquidity checks fail
- External calls revert
- Gas limits are exceeded
- Invariants are violated
- Emergency halt is triggered

Halt means:
- No retries
- No substitution
- No fallback execution

Execution stops and proceeds to settlement.

---

### F.9 Error Handling

All errors must:
- Be explicit
- Be surfaced to the vault
- Trigger halt behavior
- Be recorded for settlement

Silent failures are prohibited.

---

### F.10 Strategy Auditing Requirements

Every strategy must be:

- Independently audited
- Reviewed against this appendix
- Versioned and immutable
- Documented with risk disclosures

Audit reports must be publicly accessible.

---

### F.11 Strategy Lifecycle

The lifecycle of a strategy is:

1. Specification
2. Audit
3. Approval
4. Availability
5. User selection
6. Authorization
7. Execution
8. Halt or completion
9. Settlement
10. Deprecation (if applicable)

Deprecated strategies:
- Cannot be selected for new cycles
- Do not affect existing cycles

---

### F.12 Strategy Expansion Policy

New strategies may be added only if they:

- Preserve system invariants
- Do not introduce discretionary behavior
- Do not compromise settlement determinism
- Do not require emissions or subsidies

Strategy availability is a privilege, not a guarantee.

---

### F.13 Why Strategy Discipline Matters

Most systems fail by letting execution grow smarter than accounting.

YieldLoop forbids that.

Strategies exist to act.
Accounting exists to judge.

When strategies are simple, bounded, and honest, the system survives their failures.

That is the design.

---

## Appendix G — Security & Threat Model

This appendix defines the **explicit threat model** for YieldLoop.
Its purpose is to state clearly what the system **defends against**, what it **does not**, and where responsibility is intentionally placed.

Security is treated as a boundary problem, not a guarantee.

---

### G.1 Security Philosophy

YieldLoop does not attempt to eliminate risk.
It attempts to **bound, isolate, and surface it**.

Security design goals:
- Prevent silent loss
- Prevent cross-user contagion
- Prevent discretionary intervention
- Prevent accounting deception

YieldLoop is not designed to protect users from:
- Market risk
- Strategy risk
- Volatility
- Poor configuration choices

Those risks are explicit and accepted at authorization.

---

### G.2 In-Scope Threats (Actively Mitigated)

The system is explicitly designed to mitigate the following threats:

#### G.2.1 Cross-User Fund Contamination
- Vault isolation prevents one user’s execution from affecting another’s funds.

#### G.2.2 Unauthorized Fund Movement
- No admin or governance actor can move user funds.
- All transfers require vault-authorized execution paths.

#### G.2.3 Mid-Cycle Parameter Manipulation
- Parameters are immutable once authorized.
- No upgrades or overrides apply to active cycles.

#### G.2.4 Accounting Manipulation
- Settlement is deterministic.
- Profit must survive defined math.
- Ambiguity resolves conservatively.

#### G.2.5 Incentive Abuse
- No emissions
- No pre-minting
- No discretionary rewards

---

### G.3 Out-of-Scope Threats (Explicitly Not Defended)

The following threats are **out of scope** by design:

#### G.3.1 Market Risk
- Price movement
- Slippage
- Liquidity collapse
- Volatility spikes

#### G.3.2 Strategy Risk
- Logical flaws in strategy behavior
- Incorrect parameter choices
- Strategy underperformance

#### G.3.3 External Protocol Failure
- DEX exploits
- Bridge failures
- Oracle outages
- Protocol insolvency

Losses from these sources are isolated but not reimbursed.

#### G.3.4 Chain-Level Risk
- Consensus failures
- Reorgs
- Censorship
- Prolonged downtime

YieldLoop does not insure against chain failure.

---

### G.4 Trust Assumptions

YieldLoop makes the following explicit trust assumptions:

- Smart contracts execute as written
- Underlying chain security is intact
- External protocols behave within expected bounds
- Audits reduce, but do not eliminate, risk

There are no hidden trust assumptions.

---

### G.5 Admin Key Risk

Administrative keys may exist for:
- Emergency halts
- Prospective configuration changes
- Optional program management

Admin keys **cannot**:
- Access user vaults
- Alter settlement
- Mint LOOP
- Rescue execution
- Modify active cycles

Admin key compromise is limited in blast radius by design.

---

### G.6 Emergency Response Limitations

Emergency actions are intentionally constrained.

In an emergency:
- Execution may be halted
- New cycles may be prevented

In an emergency, the system may not:
- Reverse trades
- Compensate losses
- Alter outcomes
- Bypass settlement rules

Emergency powers preserve integrity, not value.

---

### G.7 Upgrade Risk

Protocol upgrades:
- Apply prospectively only
- Cannot modify historical cycles
- Cannot affect active execution

Users accept upgrade risk **only** for future participation.

---

### G.8 Responsible Disclosure

Security issues should be disclosed responsibly.

- Vulnerabilities affecting execution or settlement must be disclosed immediately
- No bug bounty implies guaranteed compensation
- Disclosure does not imply liability

Transparency is preferred over silence.

---

### G.9 Why This Threat Model Exists

Most failures occur when systems claim to defend against everything.

YieldLoop does the opposite.

By clearly defining what it does **not** defend against:
- Expectations remain grounded
- Risk remains visible
- Trust remains honest

Security is not a promise.

It is a boundary.

---

## Appendix H — Glossary of Terms

This glossary provides **canonical definitions** for key terms used throughout the YieldLoop documentation.
These definitions are authoritative. If a term is used inconsistently elsewhere, this appendix governs.

---

### Accounting Floor
An internal, non-market ratio representing total verified retained surplus divided by total LOOP supply.
It is not a price, promise, or guarantee.

---

### Active Execution
The state in which authorized strategy modules are actively operating within a vault under fixed parameters.
No withdrawals or configuration changes are permitted.

---

### Authorization
An explicit, irreversible user action that locks parameters and initiates a cycle.
Authorization is required before any execution can occur.

---

### Base Asset
The single asset (e.g., USDC) used as the unit of account for settlement valuation.
All multi-asset balances are converted to the base asset during settlement.

---

### Closed
The terminal state of a cycle in which settlement is finalized, outcomes are immutable, and withdrawals are enabled.

---

### Cycle
A fixed, discrete execution window with a defined start and end.
All accounting and outcomes are determined at the end of the cycle.

---

### Deterministic
A property of execution or accounting where identical inputs always produce identical outputs.
Determinism is required for settlement and strategy behavior.

---

### Dormancy
A period during which the system or a vault intentionally performs no execution due to unfavorable conditions.
Dormancy is expected and safe.

---

### Dynamic Mint Ratio (DMR)
A bounded, prospective parameter that controls the proportion of retained surplus converted into LOOP at settlement.

---

### Execution-Level Profit
Realized proceeds that occur during a cycle from completed actions.
Execution-level profit does not imply cycle-level success.

---

### Finality
The property that once a cycle settles, outcomes cannot be changed, replayed, or reinterpreted.

---

### Halted Execution
A state where execution stops early due to failure, constraint violation, or emergency halt.
Execution cannot resume once halted.

---

### Liquidity Rail
The path by which execution-level realized proceeds may be routed and withdrawn during a cycle if pre-authorized.
Liquidity rail proceeds do not affect cycle-level profit determination.

---

### LOOP
The system’s internal accounting token representing verified, retained surplus from completed cycles.
LOOP is minted only after settlement and never in advance of results.

---

### Net Result
The final outcome of a cycle calculated as ending balance minus starting balance and all costs.
A positive net result indicates verified profit; non-positive resolves to zero.

---

### Proof Rail
The path by which finalized cycle-level surplus is evaluated for LOOP minting.
Proof rail value exists only after settlement.

---

### Recovery State
A fallback state entered when settlement cannot complete deterministically.
No fees or LOOP are permitted; withdrawals are re-enabled.

---

### Retained Surplus
The portion of verified profit kept by the system after fees and user distribution.
Only retained surplus may be eligible for LOOP conversion.

---

### Settlement
The atomic process that finalizes accounting, evaluates profit, applies fees, and determines LOOP eligibility.
Settlement occurs once per cycle.

---

### Strategy Module
A predefined, audited execution component that performs authorized actions within a vault.
Strategies are deterministic, bounded, and non-adaptive.

---

### Vault
A non-custodial, isolated smart contract that holds assets, enforces execution rules, and records accounting outcomes.
Each user and the system operate through separate vaults.

---

### Zero-Result Cycle
A cycle that resolves with a non-positive net result.
Zero-result cycles produce no fees and no LOOP and are considered correct outcomes.

---

### Why This Glossary Exists

Precision prevents drift.

By defining terms explicitly, YieldLoop ensures that:
- Readers interpret the system consistently
- Auditors evaluate behavior accurately
- Implementations remain faithful to design

Words are part of the system.

---

# Appendix I — Veridic Observation & Proof Layer (Non-Authoritative)

## I.1 Purpose and Scope

This appendix defines the **Veridic Observation Layer** as an optional, non-authoritative
proof and measurement system that **observes YieldLoop outcomes without influencing them**.

Its purpose is to:
- Study Proof-of-Profit behavior in live conditions
- Generate cryptographic evidence of finalized outcomes
- Provide empirical data for Veridic Finance research
- Enable post-hoc auditability and academic analysis

This layer **does not participate in execution, accounting, settlement, or authorization**.

YieldLoop remains fully functional, correct, and auditable **with or without** Veridic
instrumentation.

---

## I.2 Non-Authoritative Guarantee (Hard Rule)

The Veridic Observation Layer is **strictly observational**.

It:
- Cannot block execution
- Cannot delay settlement
- Cannot alter balances
- Cannot affect LOOP eligibility
- Cannot impair withdrawals
- Cannot override Recovery State

Failure, absence, or malfunction of the Veridic layer **must have zero impact** on YieldLoop
behavior.

> YieldLoop produces truth.  
> Veridic records it.

---

## I.3 Observation Model

The Veridic layer observes **finalized system truths only**.

It does **not** observe:
- Individual trades
- Strategy internals
- Execution timing
- Bot actions
- UI events
- Intermediate balances

It observes **state-confirmed outcomes** emitted by the YieldLoop state machine.

---

## I.4 Proof Checkpoints (Hash Events)

The following **Proof Checkpoints** MAY emit Veridic proof records.

Each checkpoint represents a finalized, irreversible state transition.

### I.4.1 Authorization Snapshot Proof
Emitted when a vault transitions from `Configured → Authorized`.

Captured elements:
- Vault identifier (hashed)
- Cycle identifier
- Authorized parameters hash
- Starting balance snapshot hash
- Authorization timestamp

---

### I.4.2 Execution Termination Proof
Emitted when execution **fully stops**, regardless of outcome.

Valid triggers:
- Normal cycle completion
- Emergency halt
- Failure-triggered halt

Captured elements:
- Cycle identifier
- Termination reason code
- Execution end timestamp

---

### I.4.3 Settlement Proof (Primary)
Emitted **only after successful settlement finalization**.

Captured elements:
- Starting snapshot hash
- Ending snapshot hash
- Total cost hash
- Valuation source identifier
- Net result value
- Profit condition (true / false)

If settlement cannot complete deterministically, **no settlement proof is emitted**.

---

### I.4.4 Recovery Resolution Proof
Emitted when a cycle enters and exits `Recovery State`.

Captured elements:
- Recovery trigger reason
- Last verifiable state hash
- Resolution timestamp

No LOOP eligibility may exist for cycles resolved through Recovery State.

---

### I.4.5 LOOP Eligibility Proof (Conditional)
Emitted **only if**:
- Settlement completed
- Verified surplus exists
- LOOP eligibility conditions are satisfied

Captured elements:
- Eligible retained surplus value
- Dynamic Mint Ratio (bounded)
- LOOP mint amount (if any)

If no LOOP is minted, this proof may be omitted or emitted with a zero value.

---

## I.5 Proof Hash Structure (Canonical)

Each proof record MAY generate a cryptographic hash:

ProofHash = H(
CycleID ||
VaultHash ||
ProofType ||
ProofPayload ||
Timestamp
)

Where:
- `H` is a one-way cryptographic hash function
- `ProofType` is a fixed enumerated identifier
- `ProofPayload` contains only finalized values

Hash choice, encoding, and storage medium are implementation-defined.

---

## I.6 Proof Storage and Publication

Proof records MAY be:
- Stored on-chain
- Stored off-chain with on-chain anchors
- Stored in distributed databases
- Exported for audit or research

No specific storage medium is required by YieldLoop.

The Veridic layer **must not require user interaction**.

---

## I.7 Veridic Dashboard (Read-Only)

A Veridic Dashboard MAY present:

- Cycle counts
- Verified profit frequency
- Zero-result frequency
- Recovery frequency
- Proof issuance density
- Time-to-finality metrics

The dashboard:
- Is informational only
- Does not present projections
- Does not display live P&L
- Does not imply expected outcomes

---

## I.8 Relationship to the Veridic Framework

YieldLoop acts as a **demonstration environment** for the Veridic Framework.

This appendix does not assert that:
- YieldLoop requires Veridic to function
- Veridic governs YieldLoop execution
- Proof guarantees profit

It asserts only that:
> Verified surplus can be **observed, recorded, and studied** when systems enforce finality.

---

## I.9 Forward Compatibility

This observation layer is intentionally minimal.

Future Veridic systems MAY:
- Aggregate proofs across platforms
- Compare proof density between systems
- Support insurance or assurance modeling
- Extend into TradFi accounting environments

None of those capabilities are required for YieldLoop v0.3.

---

## I.10 Summary

Appendix I establishes a **measurement surface, not a control surface**.

YieldLoop remains:
- Deterministic
- Self-contained
- Auditable
- Truth-complete

Veridic remains:
- Observational
- Optional
- Empirical
- Non-intrusive

This separation is deliberate.

A system that must rely on proof to function is fragile.  
A system that produces proof naturally is durable.

YieldLoop is the latter.

---
