## Appendix A — System State Machine

This appendix defines the **complete state machine** for YieldLoop vaults and execution.
It exists to eliminate undefined behavior, prevent state ambiguity, and support deterministic implementation and audit.

All vaults—user and system-owned—must conform to this state model.

Recovery State cannot produce a worse outcome than a standard zero-result cycle and exists solely to preserve user control and accounting integrity.

---

### A.1 State Overview

Each vault exists in **exactly one state** at any given time.

Valid states are:

1. **Idle**
2. **Configured**
3. **Authorized**
4. **Active Execution**
5. **Halted Execution**
6. **Settlement**
7. **Recovery State**
8. **Closed**

No other states are permitted.

---

### A.2 State Definitions

#### A.2.1 Idle

**Description:**  
The default state of a vault.

**Characteristics:**
- No active cycle
- Funds are idle
- Withdrawals enabled
- Configuration allowed
- No execution permitted

**Allowed Transitions:**
- Idle → Configured

**Prohibited Actions:**
- Execution
- Settlement
- LOOP minting
- Fee assessment

---

#### A.2.2 Configured

**Description:**  
The vault has execution parameters defined but is not yet committed.

**Characteristics:**
- Strategy modules selected
- Parameters defined
- Funds still withdrawable
- No execution occurring

**Allowed Transitions:**
- Configured → Authorized
- Configured → Idle

**Prohibited Actions:**
- Execution
- Parameter mutation after authorization
- Settlement

---

#### A.2.3 Authorized

**Description:**  
The user has explicitly authorized a cycle.

**Characteristics:**
- Parameters locked
- Withdrawals disabled
- Cycle clock initialized
- Execution not yet started

**Allowed Transitions:**
- Authorized → Active Execution
- Authorized → Settlement (edge case: zero-length or aborted start)

**Prohibited Actions:**
- Parameter changes
- Withdrawals
- Strategy modification

---

#### A.2.4 Active Execution

**Description:**  
Strategy modules are actively operating within the vault.

**Characteristics:**
- Execution permitted only via authorized strategies
- No user or admin intervention
- No withdrawals
- No configuration changes

**Allowed Transitions:**
- Active Execution → Settlement (normal completion)
- Active Execution → Halted Execution (failure or halt condition)
- Active Execution → Settlement (time expiry)

**Prohibited Actions:**
- Parameter changes
- Execution substitution
- Manual overrides
- LOOP minting
- Fee settlement

---

#### A.2.5 Halted Execution

**Description:**  
Execution has stopped early due to failure or emergency halt.

**Characteristics:**
- No further execution permitted
- Vault remains locked
- No retries or substitutions
- Accounting not yet finalized

**Allowed Transitions:**
- Halted Execution → Settlement

**Prohibited Actions:**
- Resuming execution
- Changing parameters
- Withdrawing funds

---

#### A.2.6 Settlement

**Description:**  
Final accounting and outcome determination.

**Characteristics:**
- Execution permanently stopped
- Balances snapshotted
- Costs deducted
- Profit evaluated
- Fees applied if eligible
- LOOP minting evaluated

**Allowed Transitions:**
- Settlement → Closed
- Settlement → Recovery State (only if settlement cannot complete)

**Prohibited Actions:**
- Execution
- Parameter changes
- Withdrawals
- Re-entry into execution states

---

#### A.2.7 Recovery State

**Description:**  
Fallback state when settlement cannot complete deterministically.

**Characteristics:**
- Execution permanently halted
- No LOOP minting
- No fees charged
- Withdrawals re-enabled
- Accounting finalized using last verifiable state

**Allowed Transitions:**
- Recovery State → Closed

**Prohibited Actions:**
- Execution
- Re-settlement
- Manual outcome adjustment

---

#### A.2.8 Closed

**Description:**  
Terminal state for a completed cycle.

**Characteristics:**
- Results finalized
- Vault unlocked
- Withdrawals enabled
- Historical data immutable

**Allowed Transitions:**
- Closed → Idle (new cycle may begin)

**Prohibited Actions:**
- Modifying past outcomes
- Reopening the cycle

---

### A.3 State Transition Table

| From State         | To State            | Trigger                                   |
|-------------------|---------------------|-------------------------------------------|
| Idle              | Configured          | User defines parameters                   |
| Configured        | Authorized          | User authorizes cycle                     |
| Configured        | Idle                | User cancels configuration                |
| Authorized        | Active Execution    | Execution begins                           |
| Authorized        | Settlement          | Execution aborted before start            |
| Active Execution  | Settlement          | Normal completion or time expiry           |
| Active Execution  | Halted Execution    | Failure or emergency halt                 |
| Halted Execution  | Settlement          | Automatic transition                      |
| Settlement        | Closed              | Settlement completes successfully         |
| Settlement        | Recovery State      | Settlement cannot complete deterministically |
| Recovery State    | Closed              | Recovery finalization                     |
| Closed            | Idle                | New cycle initiation                      |

---

### A.4 Invariant Enforcement

The following invariants apply across all states:

- Execution may occur **only** in Active Execution
- Settlement may occur **only once per cycle**
- Withdrawals are enabled **only** in Idle and Closed
- Parameters are mutable **only** in Configured
- LOOP minting is evaluated **only** during Settlement
- Fees apply **only** if profit is verified at Settlement

Any state violation must cause an immediate revert.

---

### A.5 Why the State Machine Matters

This state machine exists to:

- Prevent partial execution ambiguity
- Eliminate mid-cycle discretion
- Guarantee finality
- Enable deterministic audits
- Make failure survivable

If an action cannot be mapped to a valid state transition, it is invalid by definition.

There are no implicit states.
There are no shortcuts.

---

### A.6 State Flow (Simplified) 

Idle
 │
 │ configure
 ▼
Configured
 │
 │ authorize
 ▼
Authorized
 │
 │ begin execution
 ▼
Active Execution
 │
 ├── failure / emergency halt ──▶ Halted Execution
 │                                │
 │                                ▼
 │                           Settlement
 │
 └── normal completion ─────────▶ Settlement
                                    │
                                    ├── success ──▶ Closed
                                    │
                                    └── cannot finalize ──▶ Recovery State ──▶ Closed
                                                           
Closed
 │
 │ new cycle
 ▼
Idle


---

### A.7 Mermaid Diagram

stateDiagram-v2
    [*] --> Idle

    Idle --> Configured : configure
    Configured --> Authorized : authorize
    Configured --> Idle : cancel

    Authorized --> ActiveExecution : begin execution
    Authorized --> Settlement : abort before start

    ActiveExecution --> Settlement : normal completion
    ActiveExecution --> HaltedExecution : failure / emergency halt

    HaltedExecution --> Settlement

    Settlement --> Closed : settlement complete
    Settlement --> RecoveryState : cannot finalize

    RecoveryState --> Closed

    Closed --> Idle : new cycle

    ---

    ## Appendix B — Settlement Math & Valuation Rules

This appendix defines **exact settlement math** and **deterministic valuation rules**.

Settlement is the only moment where YieldLoop recognizes cycle-level profit.
If settlement cannot be computed deterministically, the cycle resolves to **Recovery State** and **no fees / no LOOP** are permitted.

---

### B.1 Settlement Inputs (Authoritative Data)

Settlement relies only on on-chain verifiable inputs:

- `t0`: cycle start timestamp (authorization time)
- `t1`: cycle end timestamp (scheduled end or halt time)
- `S`: starting vault balances snapshot at `t0`
- `E`: ending vault balances snapshot at `t1`
- `C_gas`: total gas costs paid by the vault during the cycle
- `C_exec`: total execution costs (bot/operator/service fees if applicable and on-chain verifiable)
- `C_proto`: protocol-level fees or costs incurred by the vault (DEX fees, pool fees, claim fees)
- `V( )`: valuation function (deterministic, defined below)

No off-chain estimates are permitted.

---

### B.2 Asset Balance Snapshot Rules

#### B.2.1 Snapshot Timing
- Starting snapshot `S` is captured immediately upon cycle authorization (or first execution event, if defined).
- Ending snapshot `E` is captured immediately when execution has fully stopped and settlement begins.

#### B.2.2 Included Balances
A snapshot must include:
- All ERC-20 token balances held by the vault
- Native token balance (if applicable)
- Any strategy-specific wrapped equivalents explicitly declared in strategy specs

Excluded by default unless explicitly supported:
- Unclaimed rewards
- Pending LP fees not yet claimable to the vault
- External positions that cannot be reduced to deterministic balances at settlement time

Rule:
> If it is not an actual balance in the vault at settlement time, it does not exist for settlement.

---

### B.3 Valuation Function `V( )`

Settlement requires a deterministic conversion of multi-asset holdings into a single **Base Asset** (e.g., USDC or equivalent).

#### B.3.1 Base Asset
- Each vault has a declared base asset for settlement (e.g., USDC).
- All values are computed in base-asset terms.

#### B.3.2 Deterministic Pricing
Valuation must use one of the following deterministic sources (implementation-defined, but fixed and auditable):

1. **On-chain oracle price** at a defined block (preferred)
2. **DEX TWAP** over a fixed window ending at `t1`
3. **DEX spot price** at a defined block (allowed only if oracle/TWAP unavailable)

A single settlement must use **one pricing source per asset**.
Mixing sources for the same asset within a settlement is prohibited.

#### B.3.3 Price Ambiguity Rule (Hard)
If price cannot be resolved deterministically (oracle stale, TWAP unavailable, pool illiquid, etc.):

- Settlement must **exclude** that asset from valuation **or**
- Trigger Recovery State (implementation choice, but must be consistent and documented)

Default rule recommended:
> If any required asset valuation is ambiguous, settlement fails and enters Recovery State.

---

### B.4 Net Result Calculation (Canonical)

Let:
- `V(S)` = value of starting snapshot in base asset
- `V(E)` = value of ending snapshot in base asset

Costs are represented in base asset terms:

- `C_total = C_gas + C_exec + C_proto`

Then:

gross_change = V(E) - V(S)
net_result   = gross_change - C_total

Profit condition:

- If `net_result > 0` → Verified profit exists
- If `net_result ≤ 0` → Outcome is non-positive and treated as zero

There is no partial credit.

---

### B.5 Profit Recognition Rules

#### B.5.1 Execution-Level Profit vs Cycle-Level Surplus
- Execution-level realized proceeds may occur during the cycle.
- Cycle-level profit exists only at settlement.

Settlement ignores “feelings” of profit during execution.
Only `net_result` matters.

#### B.5.2 Unrealized Value Exclusion
Unrealized changes in external position value are excluded unless they are reduced to vault balances at settlement.

Rule:
> If you can’t snapshot it as a vault balance, it’s not in the math.

---

### B.6 Fee Calculation Rules (Settlement)

Fees apply **only** if `net_result > 0`.

Let:
- `f` = platform fee rate (prospective and cycle-locked)
- `P = net_result`

Then:

fee_amount = f * P
user_profit_after_fee = P - fee_amount

Fee constraints:
- Fees cannot exceed profit
- Fees cannot be taken from principal
- No profit → `fee_amount = 0`

---

### B.7 LOOP Eligibility Input (Retained Surplus)

Only the platform-retained portion that is designated for LOOP eligibility is considered for minting.

Let:
- `R` = portion of `fee_amount` (or other retained surplus defined by protocol) eligible for LOOP conversion
- `m` = Dynamic Mint Ratio (DMR), bounded, prospective, cycle-locked

Then:

LOOP_minted = m * R
unminted_retained_surplus = (1 - m) * R


Rules:
- LOOP minting is evaluated only in settlement
- No settlement → no LOOP
- Recovery State → no LOOP

---

### B.8 Rounding, Precision, and Dust

All settlement math must specify:
- Fixed decimal precision for base asset computations (e.g., 1e6 or 1e18 units)
- Rounding direction (recommended: round **down** to avoid over-crediting)
- Dust threshold rules (minimum values treated as zero)

Recommended rounding principle:
> Rounding must never create profit that did not exist.

---

### B.9 Settlement Determinism and Finality

Settlement must be:
- Deterministic (same inputs → same outputs)
- Atomic (single finalization point)
- Idempotent (cannot apply twice)

Once settlement completes:
- Results are immutable
- Accounting entries are permanent
- No retroactive adjustment is permitted

---

### B.10 Recovery State Trigger Conditions

Settlement transitions to Recovery State if any of the following occurs:

- Required valuation source is unavailable or ambiguous
- Critical settlement call repeatedly reverts beyond defined retry limits
- Required balances cannot be snapshotted deterministically
- Any invariants required for settlement correctness cannot be proven

Recovery rules (hard):
- Execution is permanently halted
- No fees may be collected
- No LOOP may be minted
- Withdrawals are re-enabled
- Accounting finalizes using last verifiable state

---

### B.11 Worked Example (Simple)

Assume base asset is USDC.

- `V(S) = 1,000.00`
- `V(E) = 1,060.00`
- `C_total = 20.00`

gross_change = 1,060.00 - 1,000.00 = 60.00
net_result   = 60.00 - 20.00       = 40.00  (profit exists)

If platform fee is `f = 0.20`:

fee_amount = 0.20 * 40.00 = 8.00
user_profit_after_fee = 40.00 - 8.00 = 32.00

If LOOP-eligible retained surplus is `R = 8.00` and `m = 0.50`:

LOOP_minted = 0.50 * 8.00 = 4.00
unminted_retained_surplus = 4.00

If instead `V(E)=1,010.00`:

gross_change = 10.00
net_result   = 10.00 - 20.00 = -10.00  (non-positive)
Outcome: zero, no fees, no LOOP

---

## Appendix C — Zero-Result and Dormancy Scenarios

This appendix enumerates scenarios where a cycle correctly resolves to **zero** and where the system may remain **dormant** for extended periods.

Zero is not a failure state.
Dormancy is not a malfunction.
Both are expected and correct outcomes under YieldLoop’s rules.

---

### C.1 Definition of a Zero-Result Cycle

A cycle resolves to a zero result when **net_result ≤ 0** at settlement, after all costs.

A zero result means:
- No platform fees are charged
- No LOOP is minted
- No incentives trigger
- The cycle closes normally

Zero is final and requires no explanation.

---

### C.2 Common Zero-Result Scenarios

The following scenarios **must** resolve to zero if they produce no verified surplus:

1. **Flat Price Movement**
   - Asset prices remain unchanged
   - Costs (gas, fees) consume any small gains

2. **Partial Profit Consumed by Costs**
   - Execution generates gross gains
   - Net gains are eliminated by costs

3. **Early Execution Halt**
   - Strategy halts due to constraints or failure
   - Remaining balances do not exceed starting value

4. **Liquidity Slippage**
   - Trades execute with higher-than-expected slippage
   - Gross gains fail to survive settlement math

5. **Unclaimed Rewards**
   - Rewards accrue but are not claimable at settlement
   - Unclaimed value is excluded by rule

6. **Valuation Ambiguity (Resolved Conservatively)**
   - An asset valuation is resolved at zero per policy
   - Net result becomes non-positive

In all cases, zero is the correct and final outcome.

---

### C.3 Zero Does Not Imply Loss of Principal

A zero-result cycle does **not** necessarily mean the user lost funds.

It means:
- The cycle produced no verified surplus after costs

Users may:
- Retain principal
- Withdraw immediately after settlement
- Re-authorize a new cycle or remain idle

Zero is informational, not punitive.

---

### C.4 Dormancy Scenarios

Dormancy occurs when the system intentionally does little or nothing.

Common dormancy conditions include:
- Unfavorable market conditions
- Low liquidity
- Elevated gas costs
- Strategy constraints preventing safe execution
- Governance-paused strategy availability

During dormancy:
- Cycles may be rare or absent
- LOOP supply may not grow
- System-owned capital may remain idle

This is expected behavior.

---

### C.5 Extended Dormancy Is Safe

The system is designed to remain safe during extended dormancy:

- No emissions occur
- No fees are extracted
- No user funds are placed at risk
- No accounting drift occurs

Dormancy does not degrade system integrity.

---

### C.6 Dormancy vs Failure

Dormancy must not be confused with failure.

Failure implies:
- Broken invariants
- Inability to settle
- Loss of funds due to system error

Dormancy implies:
- Conscious non-action
- Risk avoidance
- Honest acknowledgment of conditions

YieldLoop prefers dormancy over forced activity.

---

### C.7 Why Zero and Dormancy Matter

Most systems try to avoid zero outcomes because they appear unproductive.

YieldLoop embraces them because they are truthful.

Zero-result cycles and dormant periods:
- Prevent silent loss
- Expose real conditions
- Preserve capital
- Maintain trust

They are not edge cases.
They are core behaviors.

---

## Appendix D — LOOP Definitions & Edge Cases

This appendix provides **precise definitions**, boundary conditions, and edge-case handling for LOOP.
Its purpose is to eliminate ambiguity about what LOOP represents and what it cannot represent.

Nothing in this appendix expands LOOP’s role beyond what is defined in the core document.

---

### D.1 Canonical Definition of LOOP

LOOP is an internal accounting token that represents a proportional record of **verified, retained surplus** that already exists.

Formally:

> LOOP may be minted only as a consequence of finalized surplus that has survived execution, settlement, and all costs.

LOOP is evidence of past success, not a claim on future performance.

---

### D.2 LOOP Supply Invariants

The following invariants apply at all times:

- LOOP supply starts at zero
- LOOP supply may increase only during settlement
- LOOP supply may never exceed retained surplus (in base-asset terms)
- LOOP supply may stagnate indefinitely
- LOOP supply growth is independent of TVL, deposits, or user count

Any mechanism that violates these invariants is invalid by definition.

---

### D.3 Minting Edge Cases

#### D.3.1 Partial Retention
If only a portion of verified surplus is designated as LOOP-eligible:

- Only that portion may be considered for minting
- Non-eligible retained surplus remains unminted
- Unminted surplus still strengthens the accounting floor

#### D.3.2 Dynamic Mint Ratio at Zero
If the Dynamic Mint Ratio (DMR) is set to zero:

- No LOOP is minted
- All retained surplus remains unminted
- LOOP supply remains unchanged
- The accounting floor may still strengthen

This is a valid configuration.

---

### D.4 Supply Stagnation

LOOP supply may remain unchanged for extended periods due to:

- Zero-result cycles
- Dormancy
- DMR throttling
- Insufficient retained surplus

Supply stagnation is not an error condition.

---

### D.5 Accounting Floor Edge Cases

#### D.5.1 Undefined Floor (Zero Supply)
When LOOP supply is zero:

- The accounting floor is undefined
- No floor value is displayed
- No implied valuation exists

This state persists until the first successful mint.

#### D.5.2 Floor Increase Without Minting
The accounting floor may increase even if no LOOP is minted, if:

- Retained surplus grows
- LOOP supply remains constant

This behavior is mechanical and expected.

---

### D.6 Redemption Eligibility Edge Cases

Redemption is subject to system conditions and availability of retained surplus.

#### D.6.1 Insufficient Liquidity
If retained surplus is illiquid or unavailable:

- Redemption may be paused
- Requests may be queued
- Partial fulfillment may occur

This does not invalidate LOOP.

#### D.6.2 System-Wide Pause
If execution is globally paused:

- Redemption behavior is governed by defined fallback rules
- No new LOOP may be minted
- Existing LOOP remains valid

---

### D.7 LOOP and User Behavior

Holding LOOP:
- Does not affect execution
- Does not grant preferential treatment
- Does not reduce fees
- Does not influence strategy behavior

Using LOOP:
- Does not imply endorsement
- Does not guarantee value
- Does not obligate the system beyond available surplus

---

### D.8 Misinterpretations Explicitly Rejected

The following interpretations are invalid:

- LOOP represents future yield
- LOOP represents a promise of redemption at a fixed price
- LOOP price is guaranteed to rise
- LOOP protects against loss
- LOOP substitutes for accounting truth

Any messaging implying these interpretations is incorrect.

---

### D.9 Why These Definitions Matter

Most token failures occur at the edges, not the center.

By defining LOOP strictly and conservatively:
- Expectations remain bounded
- Accounting remains honest
- Survivability increases

LOOP exists to record reality—not to improve it.

---

## Appendix E — Time, Cycles, and Cutoffs

This appendix defines all time-related rules governing execution, settlement, and state transitions.
Its purpose is to eliminate ambiguity around timing, ordering, and expiration.

Time in YieldLoop is not continuous—it is segmented, bounded, and enforced.

---

### E.1 Time Authority

All time-based decisions use **on-chain block data** as the authoritative source.

- Block timestamps are used for cycle boundaries
- Block numbers may be used as secondary references where appropriate
- Off-chain clocks are never authoritative

If block time is ambiguous, conservative resolution applies.

---

### E.2 Cycle Duration

Each cycle has a defined duration set at authorization.

Rules:
- Duration is immutable once authorized
- Duration applies uniformly across strategies in the cycle
- Duration may not be extended mid-cycle
- Duration may not be shortened except via failure or halt

Cycles end when:
- The duration elapses, or
- Execution halts early due to failure or emergency halt

---

### E.3 Authorization Cutoffs

Authorization establishes the start of a cycle.

Rules:
- Authorization time is captured atomically
- No execution may occur before authorization
- Authorization cannot be replayed or duplicated
- Multiple authorizations require separate cycles

If authorization fails, the cycle does not exist.

---

### E.4 Execution Timing

Execution timing follows strict ordering:

1. Authorization completes
2. Cycle enters Authorized state
3. Execution begins
4. Execution ends
5. Settlement begins

Execution may:
- Occur immediately after authorization
- Be delayed by system scheduling
- Halt early if conditions fail

Execution may not:
- Start before authorization
- Resume after halting
- Extend beyond cycle end

---

### E.5 Settlement Timing

Settlement timing is strictly enforced.

Rules:
- Settlement begins only after execution has fully stopped
- Settlement is evaluated once per cycle
- Settlement may be retried if transient failures occur
- Settlement must complete before withdrawals are re-enabled

No execution may occur during settlement.

---

### E.6 Retry Windows

Retry behavior applies only to settlement, not execution.

Rules:
- Any caller may attempt settlement
- Retries are allowed only for deterministic failures (e.g., temporary revert)
- Retry attempts are bounded by a protocol-defined limit
- Exceeding retry limits triggers Recovery State

Retries do not modify inputs.

---

### E.7 Recovery Timeouts

If settlement cannot complete within a defined window:

- The vault enters Recovery State
- Execution is permanently halted
- LOOP minting is disabled
- Fees are disabled
- Withdrawals are re-enabled
- Accounting finalizes using last verifiable state

Recovery State is terminal for the cycle.

---

### E.8 Cutoff Enforcement

Cutoffs are enforced to prevent ambiguity:

- No late execution
- No late settlement
- No delayed accounting
- No retroactive changes

If a cutoff is missed, conservative resolution applies.

---

### E.9 Clock Drift and Chain Instability

In the event of:
- Block timestamp drift
- Chain congestion
- Temporary chain halts

The system resolves conservatively:
- Preferring earlier cutoffs
- Avoiding execution resumption
- Preserving settlement integrity

Time ambiguity never justifies optimistic accounting.

---

### E.10 Why Time Discipline Matters

Most systems blur time to hide failure.

YieldLoop enforces time to expose it.

By bounding execution and settlement in time:
- Results become auditable
- States remain deterministic
- Finality is guaranteed

Time is not a suggestion.

It is a constraint.

---

## Appendix F — Strategy Engine Specifications

This appendix defines the **formal requirements** for strategy modules in YieldLoop.
Its purpose is to ensure that all strategies are safe, auditable, bounded, and non-deceptive.

No strategy may be deployed unless it satisfies every requirement in this appendix.

---

### F.1 Strategy Role and Scope

A strategy module is a **constrained execution component**.

It:
- Executes predefined actions
- Operates only within an authorized vault
- Runs only during Active Execution
- Produces no claims, projections, or guarantees

A strategy may **fail**, **halt**, or **produce zero** without violating protocol rules.

---

### F.2 Required Strategy Interface

Every strategy must implement the following interface (conceptual):

initialize(parameters)
execute()
halt()
finalize()

Definitions:
- `initialize`: validates parameters and prepares execution
- `execute`: performs authorized actions
- `halt`: immediately stops execution
- `finalize`: performs cleanup prior to settlement

No other callable functions may affect vault balances.

---

### F.3 Determinism Requirement

Strategies must be deterministic.

Given identical:
- Inputs
- Parameters
- On-chain state

The strategy must behave identically.

Prohibited behaviors:
- Randomness
- Adaptive learning
- External off-chain signals
- Human-in-the-loop decisions
- Dynamic parameter mutation

If determinism cannot be guaranteed, the strategy is invalid.

---

### F.4 Parameter Constraints

All strategy parameters must:
- Be explicitly declared
- Have defined bounds
- Be validated at initialization
- Be immutable once authorized

Examples:
- Max trade size
- Slippage tolerance
- Asset allowlists
- Execution frequency
- Exposure limits

Parameters may not be inferred or modified mid-cycle.

---

### F.5 Capital Access Rules

Strategies may access **only** the capital explicitly allocated to them.

Rules:
- No cross-strategy borrowing
- No capital reallocation mid-cycle
- No vault-wide discretionary access
- No access to system-owned funds unless explicitly authorized

Capital isolation is mandatory.

---

### F.6 Prohibited Strategy Behaviors

Strategies must not:

- Use leverage
- Borrow or lend assets
- Enter derivatives or margin positions
- Rehypothecate assets
- Perform flash loans
- Short assets
- Chain strategies together implicitly
- Depend on continuous liquidity
- Mask losses via token rewards

If a strategy requires these behaviors, it is out of scope.

---

### F.7 External Protocol Interaction

Strategies may interact with external protocols only if:

- The interaction is explicitly defined
- All calls are bounded and auditable
- Failure modes are documented
- Reverts halt execution immediately

Retries are prohibited unless explicitly authorized and bounded.

---

### F.8 Halt Conditions

A strategy must halt immediately if:

- Slippage exceeds bounds
- Liquidity checks fail
- External calls revert
- Gas limits are exceeded
- Invariants are violated
- Emergency halt is triggered

Halt means:
- No retries
- No substitution
- No fallback execution

Execution stops and proceeds to settlement.

---

### F.9 Error Handling

All errors must:
- Be explicit
- Be surfaced to the vault
- Trigger halt behavior
- Be recorded for settlement

Silent failures are prohibited.

---

### F.10 Strategy Auditing Requirements

Every strategy must be:

- Independently audited
- Reviewed against this appendix
- Versioned and immutable
- Documented with risk disclosures

Audit reports must be publicly accessible.

---

### F.11 Strategy Lifecycle

The lifecycle of a strategy is:

1. Specification
2. Audit
3. Approval
4. Availability
5. User selection
6. Authorization
7. Execution
8. Halt or completion
9. Settlement
10. Deprecation (if applicable)

Deprecated strategies:
- Cannot be selected for new cycles
- Do not affect existing cycles

---

### F.12 Strategy Expansion Policy

New strategies may be added only if they:

- Preserve system invariants
- Do not introduce discretionary behavior
- Do not compromise settlement determinism
- Do not require emissions or subsidies

Strategy availability is a privilege, not a guarantee.

---

### F.13 Why Strategy Discipline Matters

Most systems fail by letting execution grow smarter than accounting.

YieldLoop forbids that.

Strategies exist to act.
Accounting exists to judge.

When strategies are simple, bounded, and honest, the system survives their failures.

That is the design.

---

## Appendix G — Security & Threat Model

This appendix defines the **explicit threat model** for YieldLoop.
Its purpose is to state clearly what the system **defends against**, what it **does not**, and where responsibility is intentionally placed.

Security is treated as a boundary problem, not a guarantee.

---

### G.1 Security Philosophy

YieldLoop does not attempt to eliminate risk.
It attempts to **bound, isolate, and surface it**.

Security design goals:
- Prevent silent loss
- Prevent cross-user contagion
- Prevent discretionary intervention
- Prevent accounting deception

YieldLoop is not designed to protect users from:
- Market risk
- Strategy risk
- Volatility
- Poor configuration choices

Those risks are explicit and accepted at authorization.

---

### G.2 In-Scope Threats (Actively Mitigated)

The system is explicitly designed to mitigate the following threats:

#### G.2.1 Cross-User Fund Contamination
- Vault isolation prevents one user’s execution from affecting another’s funds.

#### G.2.2 Unauthorized Fund Movement
- No admin or governance actor can move user funds.
- All transfers require vault-authorized execution paths.

#### G.2.3 Mid-Cycle Parameter Manipulation
- Parameters are immutable once authorized.
- No upgrades or overrides apply to active cycles.

#### G.2.4 Accounting Manipulation
- Settlement is deterministic.
- Profit must survive defined math.
- Ambiguity resolves conservatively.

#### G.2.5 Incentive Abuse
- No emissions
- No pre-minting
- No discretionary rewards

---

### G.3 Out-of-Scope Threats (Explicitly Not Defended)

The following threats are **out of scope** by design:

#### G.3.1 Market Risk
- Price movement
- Slippage
- Liquidity collapse
- Volatility spikes

#### G.3.2 Strategy Risk
- Logical flaws in strategy behavior
- Incorrect parameter choices
- Strategy underperformance

#### G.3.3 External Protocol Failure
- DEX exploits
- Bridge failures
- Oracle outages
- Protocol insolvency

Losses from these sources are isolated but not reimbursed.

#### G.3.4 Chain-Level Risk
- Consensus failures
- Reorgs
- Censorship
- Prolonged downtime

YieldLoop does not insure against chain failure.

---

### G.4 Trust Assumptions

YieldLoop makes the following explicit trust assumptions:

- Smart contracts execute as written
- Underlying chain security is intact
- External protocols behave within expected bounds
- Audits reduce, but do not eliminate, risk

There are no hidden trust assumptions.

---

### G.5 Admin Key Risk

Administrative keys may exist for:
- Emergency halts
- Prospective configuration changes
- Optional program management

Admin keys **cannot**:
- Access user vaults
- Alter settlement
- Mint LOOP
- Rescue execution
- Modify active cycles

Admin key compromise is limited in blast radius by design.

---

### G.6 Emergency Response Limitations

Emergency actions are intentionally constrained.

In an emergency:
- Execution may be halted
- New cycles may be prevented

In an emergency, the system may not:
- Reverse trades
- Compensate losses
- Alter outcomes
- Bypass settlement rules

Emergency powers preserve integrity, not value.

---

### G.7 Upgrade Risk

Protocol upgrades:
- Apply prospectively only
- Cannot modify historical cycles
- Cannot affect active execution

Users accept upgrade risk **only** for future participation.

---

### G.8 Responsible Disclosure

Security issues should be disclosed responsibly.

- Vulnerabilities affecting execution or settlement must be disclosed immediately
- No bug bounty implies guaranteed compensation
- Disclosure does not imply liability

Transparency is preferred over silence.

---

### G.9 Why This Threat Model Exists

Most failures occur when systems claim to defend against everything.

YieldLoop does the opposite.

By clearly defining what it does **not** defend against:
- Expectations remain grounded
- Risk remains visible
- Trust remains honest

Security is not a promise.

It is a boundary.

---

## Appendix H — Glossary of Terms

This glossary provides **canonical definitions** for key terms used throughout the YieldLoop documentation.
These definitions are authoritative. If a term is used inconsistently elsewhere, this appendix governs.

---

### Accounting Floor
An internal, non-market ratio representing total verified retained surplus divided by total LOOP supply.
It is not a price, promise, or guarantee.

---

### Active Execution
The state in which authorized strategy modules are actively operating within a vault under fixed parameters.
No withdrawals or configuration changes are permitted.

---

### Authorization
An explicit, irreversible user action that locks parameters and initiates a cycle.
Authorization is required before any execution can occur.

---

### Base Asset
The single asset (e.g., USDC) used as the unit of account for settlement valuation.
All multi-asset balances are converted to the base asset during settlement.

---

### Closed
The terminal state of a cycle in which settlement is finalized, outcomes are immutable, and withdrawals are enabled.

---

### Cycle
A fixed, discrete execution window with a defined start and end.
All accounting and outcomes are determined at the end of the cycle.

---

### Deterministic
A property of execution or accounting where identical inputs always produce identical outputs.
Determinism is required for settlement and strategy behavior.

---

### Dormancy
A period during which the system or a vault intentionally performs no execution due to unfavorable conditions.
Dormancy is expected and safe.

---

### Dynamic Mint Ratio (DMR)
A bounded, prospective parameter that controls the proportion of retained surplus converted into LOOP at settlement.

---

### Execution-Level Profit
Realized proceeds that occur during a cycle from completed actions.
Execution-level profit does not imply cycle-level success.

---

### Finality
The property that once a cycle settles, outcomes cannot be changed, replayed, or reinterpreted.

---

### Halted Execution
A state where execution stops early due to failure, constraint violation, or emergency halt.
Execution cannot resume once halted.

---

### Liquidity Rail
The path by which execution-level realized proceeds may be routed and withdrawn during a cycle if pre-authorized.
Liquidity rail proceeds do not affect cycle-level profit determination.

---

### LOOP
The system’s internal accounting token representing verified, retained surplus from completed cycles.
LOOP is minted only after settlement and never in advance of results.

---

### Net Result
The final outcome of a cycle calculated as ending balance minus starting balance and all costs.
A positive net result indicates verified profit; non-positive resolves to zero.

---

### Proof Rail
The path by which finalized cycle-level surplus is evaluated for LOOP minting.
Proof rail value exists only after settlement.

---

### Recovery State
A fallback state entered when settlement cannot complete deterministically.
No fees or LOOP are permitted; withdrawals are re-enabled.

---

### Retained Surplus
The portion of verified profit kept by the system after fees and user distribution.
Only retained surplus may be eligible for LOOP conversion.

---

### Settlement
The atomic process that finalizes accounting, evaluates profit, applies fees, and determines LOOP eligibility.
Settlement occurs once per cycle.

---

### Strategy Module
A predefined, audited execution component that performs authorized actions within a vault.
Strategies are deterministic, bounded, and non-adaptive.

---

### Vault
A non-custodial, isolated smart contract that holds assets, enforces execution rules, and records accounting outcomes.
Each user and the system operate through separate vaults.

---

### Zero-Result Cycle
A cycle that resolves with a non-positive net result.
Zero-result cycles produce no fees and no LOOP and are considered correct outcomes.

---

### Why This Glossary Exists

Precision prevents drift.

By defining terms explicitly, YieldLoop ensures that:
- Readers interpret the system consistently
- Auditors evaluate behavior accurately
- Implementations remain faithful to design

Words are part of the system.

---

# Appendix I — Veridic Observation & Proof Layer (Non-Authoritative)

## I.1 Purpose and Scope

This appendix defines the **Veridic Observation Layer** as an optional, non-authoritative
proof and measurement system that **observes YieldLoop outcomes without influencing them**.

Its purpose is to:
- Study Proof-of-Profit behavior in live conditions
- Generate cryptographic evidence of finalized outcomes
- Provide empirical data for Veridic Finance research
- Enable post-hoc auditability and academic analysis

This layer **does not participate in execution, accounting, settlement, or authorization**.

YieldLoop remains fully functional, correct, and auditable **with or without** Veridic
instrumentation.

---

## I.2 Non-Authoritative Guarantee (Hard Rule)

The Veridic Observation Layer is **strictly observational**.

It:
- Cannot block execution
- Cannot delay settlement
- Cannot alter balances
- Cannot affect LOOP eligibility
- Cannot impair withdrawals
- Cannot override Recovery State

Failure, absence, or malfunction of the Veridic layer **must have zero impact** on YieldLoop
behavior.

> YieldLoop produces truth.  
> Veridic records it.

---

## I.3 Observation Model

The Veridic layer observes **finalized system truths only**.

It does **not** observe:
- Individual trades
- Strategy internals
- Execution timing
- Bot actions
- UI events
- Intermediate balances

It observes **state-confirmed outcomes** emitted by the YieldLoop state machine.

---

## I.4 Proof Checkpoints (Hash Events)

The following **Proof Checkpoints** MAY emit Veridic proof records.

Each checkpoint represents a finalized, irreversible state transition.

### I.4.1 Authorization Snapshot Proof
Emitted when a vault transitions from `Configured → Authorized`.

Captured elements:
- Vault identifier (hashed)
- Cycle identifier
- Authorized parameters hash
- Starting balance snapshot hash
- Authorization timestamp

---

### I.4.2 Execution Termination Proof
Emitted when execution **fully stops**, regardless of outcome.

Valid triggers:
- Normal cycle completion
- Emergency halt
- Failure-triggered halt

Captured elements:
- Cycle identifier
- Termination reason code
- Execution end timestamp

---

### I.4.3 Settlement Proof (Primary)
Emitted **only after successful settlement finalization**.

Captured elements:
- Starting snapshot hash
- Ending snapshot hash
- Total cost hash
- Valuation source identifier
- Net result value
- Profit condition (true / false)

If settlement cannot complete deterministically, **no settlement proof is emitted**.

---

### I.4.4 Recovery Resolution Proof
Emitted when a cycle enters and exits `Recovery State`.

Captured elements:
- Recovery trigger reason
- Last verifiable state hash
- Resolution timestamp

No LOOP eligibility may exist for cycles resolved through Recovery State.

---

### I.4.5 LOOP Eligibility Proof (Conditional)
Emitted **only if**:
- Settlement completed
- Verified surplus exists
- LOOP eligibility conditions are satisfied

Captured elements:
- Eligible retained surplus value
- Dynamic Mint Ratio (bounded)
- LOOP mint amount (if any)

If no LOOP is minted, this proof may be omitted or emitted with a zero value.

---

## I.5 Proof Hash Structure (Canonical)

Each proof record MAY generate a cryptographic hash:

ProofHash = H(
CycleID ||
VaultHash ||
ProofType ||
ProofPayload ||
Timestamp
)

Where:
- `H` is a one-way cryptographic hash function
- `ProofType` is a fixed enumerated identifier
- `ProofPayload` contains only finalized values

Hash choice, encoding, and storage medium are implementation-defined.

---

## I.6 Proof Storage and Publication

Proof records MAY be:
- Stored on-chain
- Stored off-chain with on-chain anchors
- Stored in distributed databases
- Exported for audit or research

No specific storage medium is required by YieldLoop.

The Veridic layer **must not require user interaction**.

---

## I.7 Veridic Dashboard (Read-Only)

A Veridic Dashboard MAY present:

- Cycle counts
- Verified profit frequency
- Zero-result frequency
- Recovery frequency
- Proof issuance density
- Time-to-finality metrics

The dashboard:
- Is informational only
- Does not present projections
- Does not display live P&L
- Does not imply expected outcomes

---

## I.8 Relationship to the Veridic Framework

YieldLoop acts as a **demonstration environment** for the Veridic Framework.

This appendix does not assert that:
- YieldLoop requires Veridic to function
- Veridic governs YieldLoop execution
- Proof guarantees profit

It asserts only that:
> Verified surplus can be **observed, recorded, and studied** when systems enforce finality.

---

## I.9 Forward Compatibility

This observation layer is intentionally minimal.

Future Veridic systems MAY:
- Aggregate proofs across platforms
- Compare proof density between systems
- Support insurance or assurance modeling
- Extend into TradFi accounting environments

None of those capabilities are required for YieldLoop v0.3.

---

## I.10 Summary

Appendix I establishes a **measurement surface, not a control surface**.

YieldLoop remains:
- Deterministic
- Self-contained
- Auditable
- Truth-complete

Veridic remains:
- Observational
- Optional
- Empirical
- Non-intrusive

This separation is deliberate.

A system that must rely on proof to function is fragile.  
A system that produces proof naturally is durable.

YieldLoop is the latter.

---

# Appendix J — Proof-of-Impact (PoI) Interface (Dormant / Non-Binding)

## J.1 Purpose

This appendix defines a **dormant Proof-of-Impact (PoI) interface** that may be activated in
future systems operating under the Veridic Framework.

YieldLoop v0.3:
- Does **not** require Proof-of-Impact
- Does **not** route funds to impact
- Does **not** claim social or ethical benefit
- Does **not** measure or report impact

This appendix exists solely to:
- Reserve interface boundaries
- Prevent architectural conflicts later
- Demonstrate forward compatibility with Veridic Finance

No behavior described herein is active.

---

## J.2 Dormant Status (Hard Rule)

Proof-of-Impact is **inactive by default**.

In YieldLoop v0.3:
- No capital is diverted for impact
- No fees are earmarked for impact
- No LOOP minting is conditional on impact
- No user funds are affected
- No promises, claims, or representations of good are made

If Proof-of-Impact is not explicitly enabled in a future version,
it does not exist.

Dormant means dormant.

---

## J.3 Conceptual Definition (Non-Operational)

Proof-of-Impact is defined as:

> A verifiable transfer of value from verified surplus to a measurable external outcome,
> recorded with the same finality and proof standards as profit.

Impact is not assumed.
Impact is not inferred.
Impact is not marketed.

Impact exists only if it is:
- Quantified
- Transferred
- Verified
- Recorded

---

## J.4 Separation from Proof-of-Profit

Proof-of-Impact is **strictly downstream** of Proof-of-Profit.

Ordering is non-negotiable:

1. Execution completes
2. Settlement finalizes
3. Profit is verified (or rejected)
4. Only then MAY impact be evaluated

If Proof-of-Profit fails:
- Proof-of-Impact cannot exist

No impact may be claimed on unrealized, projected, or assumed gain.

---

## J.5 Hypothetical Impact Flow (Illustrative Only)

If enabled in a future system, a compliant impact flow would be:

1. Verified surplus exists at settlement
2. A bounded, prospective impact ratio is applied
3. Impact allocation is computed from retained surplus only
4. Transfer is executed to a declared destination
5. Transfer is cryptographically recorded
6. Impact proof is emitted

YieldLoop v0.3 performs **none** of these steps.

---

## J.6 Impact Proof Record (Future-Compatible)

A future Proof-of-Impact record MAY include:

- Cycle identifier
- Verified surplus reference hash
- Impact ratio applied
- Impact amount
- Destination identifier (hashed)
- Transfer transaction reference
- Timestamp

No such record is generated in YieldLoop v0.3.

---

## J.7 Non-Interference Guarantee

Whether Proof-of-Impact exists or not:

- Execution rules do not change
- Settlement math does not change
- LOOP eligibility does not change
- User outcomes do not change
- Recovery behavior does not change

Impact logic may never:
- Create profit
- Mask loss
- Justify dilution
- Alter accounting truth

Impact follows truth.  
Truth does not follow impact.

---

## J.8 Governance and Activation (Future Only)

Any future activation of Proof-of-Impact would require:
- Explicit system versioning
- Prospective-only application
- Full disclosure to users
- No retroactive application
- Clear opt-in or opt-out boundaries

No such governance exists in YieldLoop v0.3.

---

## J.9 Why This Appendix Exists

This appendix exists to make one thing explicit:

> YieldLoop is not pretending to be ethical.
> It is pretending to be honest.

If honesty produces surplus, impact may follow.
If it does not, no narrative is invented.

This appendix prevents future systems from:
- Bolting on morality as marketing
- Blurring profit with purpose
- Retroactively justifying outcomes

---

## J.10 Summary

Proof-of-Impact is:
- Defined, but inactive
- Reserved, but non-binding
- Separated, not entangled
- Conditional, not assumed

YieldLoop v0.3 proves profit or zero.

If impact is ever added,
it will be proven the same way —
or it will not exist at all.

---

# Appendix K — Veridic Metrics & Definitions (Observational / Non-Authoritative)

## K.1 Purpose

This appendix defines a **standard vocabulary and metric set** for observing, analyzing, and
comparing systems that enforce Proof-of-Profit behavior.

These metrics:
- Do **not** influence execution
- Do **not** alter settlement
- Do **not** affect user outcomes
- Do **not** imply guarantees

They exist solely to:
- Measure system truth density
- Enable economic analysis
- Support academic, audit, and policy review
- Provide a common language for Verified Finance

YieldLoop v0.3 emits **sufficient finalized data** to support these metrics without modification.

---

## K.2 Core Veridic Definitions

### K.2.1 Verified Surplus
A positive net result that survives:
- Execution completion
- Deterministic settlement
- Full cost deduction

If surplus cannot be verified with certainty, it does not exist.

---

### K.2.2 Proof-of-Profit (PoP)
The condition in which verified surplus exists **only after finalization**.

Formally:

PoP = true  ⇔  net_result > 0 at settlement
PoP = false ⇔  net_result ≤ 0

PoP is binary.
There is no partial or probabilistic profit.

---

### K.2.3 Zero-Result Cycle
A completed cycle where:

net_result ≤ 0

Zero-result cycles are:
- Correct
- Expected
- Non-failing
- Final

Zero is not loss.
Zero is resolved truth.

---

### K.2.4 Proof Event
A finalized, irreversible state confirmation that MAY be recorded as a Veridic proof.

Examples:
- Authorization snapshot
- Settlement finalization
- Recovery resolution
- LOOP eligibility decision

Proof events are **outcomes**, not activities.

---

## K.3 Primary Veridic Metrics

### K.3.1 Proof Density (PD)

Measures how often a system produces verifiable truth.

PD = (Number of cycles with finalized settlement proofs) / (Total completed cycles)

High PD indicates:
- Strong finality enforcement
- Low ambiguity
- High auditability

---

### K.3.2 Verified Profit Frequency (VPF)

Measures how often verified surplus occurs.

VPF = (Cycles with PoP = true) / (Total completed cycles)

This metric:
- Does not predict returns
- Does not imply future performance
- Describes observed reality only

---

### K.3.3 Zero Resolution Rate (ZRR)

Measures how often systems resolve cleanly to zero.

ZRR = (Zero-result cycles) / (Total completed cycles)

High ZRR does **not** indicate failure.
It indicates refusal to fabricate profit.

---

### K.3.4 Recovery Invocation Rate (RIR)

Measures settlement stress and ambiguity.

RIR = (Cycles resolved via Recovery State) / (Total completed cycles)

Used to evaluate:
- Pricing determinism
- Oracle reliability
- Valuation robustness

---

### K.3.5 Time-to-Finality (TTF)

Measures how long truth takes to become final.

TTF = Settlement timestamp − Authorization timestamp

Lower TTF improves:
- Audit clarity
- User certainty
- System responsiveness

---

## K.4 Secondary Analytical Metrics (Optional)

### K.4.1 Surplus Persistence Ratio (SPR)

Measures whether verified surplus continues to appear over time.

SPR = Rolling average of verified surplus over N cycles

Used for:
- Long-term sustainability analysis
- Cross-system comparison

---

### K.4.2 Proof Volatility (PV)

Measures variance in verified outcomes, not price.

PV = Variance of net_result across cycles

High PV reflects market exposure, not system weakness.

---

### K.4.3 Entropy Reduction Indicator (ERI) (Experimental)

Measures reduction in outcome ambiguity.

Conceptually:

ERI ∝ Reduction in unverifiable states over time

This metric is observational and non-normative.

---

## K.5 Metric Interpretation Rules (Hard)

The following interpretations are **explicitly prohibited**:

- Interpreting VPF as yield expectation
- Interpreting PD as safety guarantee
- Interpreting low ZRR as superiority
- Interpreting historical metrics as promises

Metrics describe **what happened**, not what will happen.

---

## K.6 Cross-System Comparability

Veridic metrics enable comparison between systems that:
- Enforce finality
- Settle deterministically
- Reject assumed profit

They are not applicable to:
- Rolling-position systems
- Mark-to-market dashboards
- Emissions-driven yield models
- Systems without hard settlement

Applying Veridic metrics to such systems will collapse to noise.

---

## K.7 Relationship to YieldLoop v0.3

YieldLoop v0.3:
- Naturally emits all required data
- Requires no modification
- Does not expose metrics in the UI by default
- Does not advertise Veridic scoring

Veridic metrics are derived **after the fact**.

---

## K.8 Why These Metrics Matter

Traditional finance measures motion.
DeFi dashboards measure illusion.
Veridic metrics measure **truth density**.

They answer questions markets usually avoid:
- Did anything actually finish?
- Was surplus real?
- How often does the system tell zero?
- How often does ambiguity force honesty?

These are not marketing questions.
They are survival questions.

---

## K.9 Summary

Appendix K defines:
- A neutral measurement vocabulary
- Binary profit recognition
- Zero as a first-class outcome
- Proof as an observable property

YieldLoop does not depend on these metrics.

But systems that endure will.

---

# Appendix L — Veridic Proof Types & Hash Enumeration (Auditor-Facing)

## L.1 Purpose

This appendix defines the **canonical set of Veridic proof types** and their corresponding
hash categories.

It exists to:
- Eliminate ambiguity about what is being proven
- Prevent over-hashing of non-final events
- Enable deterministic audit trails
- Support cross-system comparability

These proof types are **observational only** and **non-authoritative**.

YieldLoop execution, settlement, and accounting do not depend on their existence.

---

## L.2 Proof Design Principles (Hard Rules)

All Veridic proof types MUST obey the following:

1. **Finality Only**  
   Proofs may be emitted only for irreversible outcomes.

2. **State-Based, Not Event-Based**  
   Proofs correspond to state transitions, not activity logs.

3. **Minimal Surface Area**  
   Only economically meaningful truths are hashed.

4. **Deterministic Inputs**  
   All proof payload elements must be deterministic or excluded.

5. **Non-Blocking**  
   Proof generation failure must not affect system behavior.

---

## L.3 Canonical Proof Type Enumeration

Each proof type is assigned a fixed identifier.

| Proof Type Code | Proof Name                         | Trigger Condition |
|-----------------|------------------------------------|------------------|
| `P-AUTH`        | Authorization Snapshot Proof       | Vault enters `Authorized` |
| `P-EXEC-END`    | Execution Termination Proof        | Execution fully stops |
| `P-SETTLE`      | Settlement Finalization Proof      | Settlement completes successfully |
| `P-RECOVERY`    | Recovery Resolution Proof          | Recovery State resolves |
| `P-LOOP-ELIG`   | LOOP Eligibility Proof             | Verified surplus exists |
| `P-LOOP-MINT`   | LOOP Mint Record Proof             | LOOP minted (>0) |
| `P-CLOSE`       | Cycle Closure Proof                | Vault enters `Closed` |

No other proof types are recognized in YieldLoop v0.3.

---

## L.4 Proof Payload Definitions

### L.4.1 `P-AUTH` — Authorization Snapshot Proof

Payload MUST include:
- Cycle identifier
- Vault identifier (hashed)
- Authorized parameter hash
- Starting balance snapshot hash
- Authorization timestamp

Payload MUST NOT include:
- User identity
- Strategy internals
- Expected outcomes

---

### L.4.2 `P-EXEC-END` — Execution Termination Proof

Payload MUST include:
- Cycle identifier
- Termination reason code
- Execution end timestamp

Valid termination reasons:
- Normal completion
- Failure halt
- Emergency halt
- Time expiration

---

### L.4.3 `P-SETTLE` — Settlement Finalization Proof

Payload MUST include:
- Starting snapshot hash
- Ending snapshot hash
- Aggregate cost hash
- Valuation source identifier
- Net result value
- Profit condition flag (true / false)

If settlement does not complete deterministically,
this proof MUST NOT be emitted.

---

### L.4.4 `P-RECOVERY` — Recovery Resolution Proof

Payload MUST include:
- Recovery trigger reason
- Last verifiable state hash
- Resolution timestamp

This proof explicitly indicates:
- No profit recognized
- No fees charged
- No LOOP eligibility

---

### L.4.5 `P-LOOP-ELIG` — LOOP Eligibility Proof

Emitted ONLY if:
- `P-SETTLE` exists
- Profit condition is true

Payload MUST include:
- Verified retained surplus reference
- Dynamic Mint Ratio applied
- Eligible LOOP amount (pre-mint)

If surplus exists but LOOP mint ratio is zero,
this proof MAY be omitted or emitted with zero value.

---

### L.4.6 `P-LOOP-MINT` — LOOP Mint Record Proof

Emitted ONLY if LOOP tokens are minted (>0).

Payload MUST include:
- Minted LOOP amount
- Mint transaction reference
- Timestamp

This proof does not assert value,
only issuance based on prior eligibility.

---

### L.4.7 `P-CLOSE` — Cycle Closure Proof

Payload MUST include:
- Cycle identifier
- Closure timestamp
- Final state identifier

This proof confirms irreversibility.

---

## L.5 Canonical Proof Hash Construction

Each proof MAY generate a hash using:

ProofHash = H(
ProofType ||
CycleID ||
VaultHash ||
PayloadHash ||
Timestamp
)

Where:
- `H` is a cryptographically secure one-way hash
- `PayloadHash` is derived from the canonical payload
- Ordering and encoding are fixed per implementation

Hash collisions are treated as catastrophic
and invalidate the proof record.

---

## L.6 Proof Ordering Guarantees

The following ordering MUST be preserved:

P-AUTH
→ P-EXEC-END
→ (P-SETTLE | P-RECOVERY)
→ [P-LOOP-ELIG]
→ [P-LOOP-MINT]
→ P-CLOSE

Bracketed proofs are conditional.

Out-of-order proofs are invalid.

---

## L.7 Audit Interpretation Rules (Hard)

Auditors MUST interpret proofs as follows:

- Absence of proof ≠ failure
- Presence of proof ≠ guarantee
- Proof confirms **what happened**, not why
- Proof does not imply safety, yield, or expectation

Proofs replace narrative.
They do not replace judgment.

---

## L.8 Extensibility

Future systems MAY:
- Add new proof types
- Deprecate unused types
- Aggregate proofs cross-platform

YieldLoop v0.3 recognizes only the enumerated set above.

---

## L.9 Summary

Appendix L defines:
- What is provable
- When proof is emitted
- What auditors may rely on
- What proofs explicitly do NOT claim

YieldLoop produces finalized truth.
Veridic hashes only what cannot change.

Anything else is noise.

---

# Appendix M — Veridic Accounting vs Traditional Financial Accounting

## M.1 Purpose

This appendix compares **Veridic accounting principles** as observed in YieldLoop with
traditional accounting frameworks used in corporate finance, fund accounting, and DeFi
reporting.

It exists to:
- Clarify what YieldLoop is and is not doing
- Prevent category errors by auditors or regulators
- Show alignment where it exists and divergence where it is intentional

This appendix is explanatory only.
It does not modify system behavior.

---

## M.2 Traditional Accounting Overview (Context)

Traditional financial accounting generally operates under the following characteristics:

- Period-based reporting (monthly, quarterly, annual)
- Accrual accounting and estimates
- Mark-to-market valuation
- Ongoing positions without forced closure
- Profit reported before full realization in some cases
- Audit performed after the fact

These systems are effective for large organizations but rely on:
- Assumptions
- Estimates
- Management judgment
- Deferred finality

---

## M.3 Veridic Accounting Overview

Veridic accounting, as demonstrated by YieldLoop, operates under different constraints:

- Cycle-based finalization
- Deterministic settlement
- Binary profit recognition
- No accruals
- No estimates
- No rolling positions
- No profit without closure

Every accounting period **must end**.
Every result **must finalize**.

There is no concept of “in-progress profit.”

---

## M.4 Core Conceptual Differences

| Dimension | Traditional Accounting | Veridic Accounting |
|--------|----------------------|-------------------|
| Time Model | Continuous / Periodic | Discrete cycles |
| Profit Recognition | Accrual / Estimate-based | Finalized only |
| Valuation | Mark-to-market allowed | Deterministic only |
| Interim Reporting | Common | Prohibited |
| Profit Smoothing | Allowed | Impossible |
| Carryover States | Common | Disallowed |
| Audit Timing | Retrospective | Embedded |
| Failure Handling | Write-downs | Zero resolution |

---

## M.5 Profit Recognition Comparison

### Traditional Model
Profit may be recognized:
- Before cash realization
- Based on fair value estimates
- With deferred settlement
- Subject to later restatement

### Veridic Model
Profit is recognized only if:

Ending balance
− Starting balance
− All costs

0

If this condition is not met at finalization:
- Profit does not exist
- Fees do not apply
- Incentives do not trigger

There are no restatements.
There is no revision.
There is no appeal.

---

## M.6 Treatment of Loss, Zero, and Dormancy

### Traditional Systems
- Losses may be deferred
- Losses may be amortized
- Flat performance may still generate fees
- Dormancy is often hidden

### Veridic Systems
- Losses resolve immediately
- Zero is a first-class outcome
- No profit → no fee
- Dormancy is explicit and expected

Zero is not failure.
Zero is closure.

---

## M.7 Audit Implications

### Traditional Audit
- Samples transactions
- Reviews controls
- Tests assumptions
- Occurs after reporting

### Veridic Observation
- Reviews finalized states
- Verifies deterministic math
- Confirms finality
- Occurs continuously or post-cycle

Auditors do not need to infer intent.
They verify outcomes.

---

## M.8 Relationship to Double-Entry Accounting

Veridic accounting does not replace double-entry accounting.
It enforces **double-entry finality**.

Every cycle effectively becomes:
- A closed ledger
- A balanced equation
- A self-contained audit unit

This makes cycles independently verifiable.

---

## M.9 Regulatory Interpretation Guidance

Important clarifications:

- YieldLoop does not present itself as a bank
- YieldLoop does not present itself as a savings account
- YieldLoop does not promise income
- YieldLoop does not guarantee capital preservation
- YieldLoop does not smooth results
- YieldLoop does not pool customer funds

Accounting outcomes are factual statements, not promises.

---

## M.10 Why This Matters

Many financial failures occur not because systems lose money,
but because they obscure when and how they lost it.

Veridic accounting removes that ambiguity.

It does not make systems safer.
It makes them **honest sooner**.

---

## M.11 Summary

This appendix establishes that:

- Veridic accounting is stricter than traditional accounting
- YieldLoop voluntarily accepts harsher finality
- No assumption-based profit exists
- No narrative accounting is permitted

Traditional systems optimize continuity.
Veridic systems optimize truth.

YieldLoop chooses truth.

---

# Appendix N — Veridic Dashboard (Read-Only Observation Interface)

## N.1 Purpose

This appendix defines a **read-only observation dashboard** for Veridic data derived from
YieldLoop cycles.

The dashboard exists to:
- Display finalized outcomes only
- Expose proof density and resolution behavior
- Enable audit, academic, and economic review

The dashboard:
- Does not connect wallets
- Does not initiate transactions
- Does not influence execution, settlement, or minting
- Does not present yield, APY, or forecasts

It is a **viewer of truth**, not a control surface.

---

## N.2 Design Principles (Hard)

1. **Finality Only**  
   No in-progress or estimated data is displayed.

2. **Binary Clarity**  
   Outcomes resolve to *profit verified* or *zero*.

3. **No Narrative Metrics**  
   Nothing implying performance, safety, or expectation.

4. **Human-Readable First**  
   Auditors and economists must understand it without context.

---

## N.3 Top-Level Dashboard View

### N.3.1 System Overview (Counts Only)

| Item | Description |
|----|----|
| Completed Cycles | Total cycles that reached finality |
| Active Cycles | Cycles currently executing (count only) |
| Settlement Success | Cycles finalized without recovery |
| Recovery Resolutions | Cycles resolved via Recovery State |
| Total Proof Events | All emitted proof records |

No financial values appear in this section.

---

### N.3.2 Outcome Distribution

| Outcome Type | Count | Meaning |
|-------------|------|--------|
| Verified Profit | Cycles where surplus survived settlement |
| Zero Result | Cycles where net result ≤ 0 |
| Recovery | Cycles resolved conservatively due to ambiguity |

This table describes **what happened**, not how often it will happen.

---

## N.4 Veridic Metrics Panel

Derived from Appendix K. All values are historical.

| Metric | Description |
|------|-------------|
| Proof Density (PD) | Cycles producing finalized settlement proofs |
| Verified Profit Frequency (VPF) | Share of cycles with verified surplus |
| Zero Resolution Rate (ZRR) | Share of cycles resolving to zero |
| Recovery Invocation Rate (RIR) | Share of cycles entering Recovery State |
| Avg. Time-to-Finality (TTF) | Authorization → settlement duration |

No metric is predictive.  
No metric is ranked or scored.

---

## N.5 Proof Timeline (Global)

Chronological list of proof events.

Each row represents **one irreversible fact**.

| Time | Proof Type | Cycle ID | Notes |
|----|-----------|---------|------|
| t₁ | P-AUTH | C-123 | Cycle authorized |
| t₂ | P-EXEC-END | C-123 | Execution halted normally |
| t₃ | P-SETTLE | C-123 | Settlement finalized |
| t₄ | P-CLOSE | C-123 | Cycle closed |

Recovery cycles substitute `P-SETTLE` with `P-RECOVERY`.

---

## N.6 Single-Cycle Detail View (Optional)

Accessible by selecting a completed cycle.

### N.6.1 Cycle Summary

| Field | Value |
|-----|------|
| Cycle ID | C-123 |
| Vault Reference | Hashed |
| Authorized At | Timestamp |
| Execution Ended | Timestamp |
| Settled At | Timestamp |
| Final Outcome | Verified Profit / Zero / Recovery |

---

### N.6.2 Proof Records

| Proof Type | Hash Reference | Timestamp |
|-----------|--------------|-----------|
| P-AUTH | hash(…) | t₁ |
| P-EXEC-END | hash(…) | t₂ |
| P-SETTLE / P-RECOVERY | hash(…) | t₃ |
| P-CLOSE | hash(…) | t₄ |

No strategy details.  
No trade data.  
No balances unless explicitly permitted.

---

## N.7 Explicit Exclusions (Hard)

The dashboard MUST NOT display:

- Live balances
- Estimated profit
- Unrealized value
- APY or yield curves
- Strategy performance comparisons
- Rankings or gamification
- Forward-looking indicators

If it didn’t finalize, it doesn’t appear.

---

## N.8 Relationship to YieldLoop

The dashboard:
- Consumes finalized state outputs
- Observes settlement results
- Reflects recovery conservatism
- Makes zero a visible outcome

YieldLoop does not depend on this dashboard.
The dashboard depends entirely on YieldLoop finality.

---

## N.9 Summary

Appendix N defines a **truth viewer**, not a performance dashboard.

It shows:
- That cycles end
- That outcomes finalize
- That zero is common
- That ambiguity resolves conservatively
- That proof is sparse by design

Nothing here promises gain.
Everything here proves completion.

That is the point.

